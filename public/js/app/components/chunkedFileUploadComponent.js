function u(n){return{uploading:!1,uploadingFiles:[],uploadedFiles:[],error:null,state:n.state,abortControllers:new Map,updatingState:!1,config:{acceptedFileTypes:n.acceptedFileTypes||[],chunkSize:n.chunkSize||5*1024*1024,chunkUploadUrl:n.chunkUploadUrl,chunkDeleteUrl:n.chunkDeleteUrl,chunkCancelUrl:n.chunkCancelUrl,isChunked:n.isChunked||!1,isDisabled:n.isDisabled||!1,isMultiple:n.isMultiple||!1,maxFiles:n.maxFiles||1,maxParallelUploads:n.maxParallelUploads||3,maxSize:n.maxSize,minSize:n.minSize,placeholder:n.placeholder,statePath:n.statePath,uploadingMessage:n.uploadingMessage||"Uploading...",storage:n.storage||{disk:"public",finalDir:"uploads"}},init(){this.loadExistingFiles(),this.$watch("state",()=>this.loadExistingFiles()),this.setupDragAndDrop(),window.addEventListener("beforeunload",()=>this.cleanup())},loadExistingFiles(){if(!this.state||this.updatingState)return;let e=Array.isArray(this.state)?this.state:[this.state];(this.uploadedFiles.length===0||e.length!==this.uploadedFiles.length)&&(this.uploadedFiles=e.map((s,t)=>({key:this.generateFileKey(),name:s,size:0,url:this.buildFileUrl(s),type:null})))},setupDragAndDrop(){let e=this.$el,s=this.$el.querySelector(".fi-fo-file-upload-dropzone");!e||!s||(["dragenter","dragover","dragleave","drop"].forEach(t=>{e.addEventListener(t,this.preventDefaults,!1)}),["dragenter","dragover"].forEach(t=>{e.addEventListener(t,()=>this.highlight(s),!1)}),["dragleave","drop"].forEach(t=>{e.addEventListener(t,()=>this.unhighlight(s),!1)}),e.addEventListener("drop",this.handleDrop.bind(this),!1))},preventDefaults(e){e.preventDefault(),e.stopPropagation()},highlight(e){e.classList.add("drag-over")},unhighlight(e){e.classList.remove("drag-over")},handleDrop(e){let t=e.dataTransfer.files;this.handleFiles(Array.from(t))},handleFileSelect(e){let s=Array.from(e.target.files);this.handleFiles(s),e.target.value=""},handleFiles(e){if(e.length===0)return;this.error=null;let s=this.validateFiles(e);if(!s.valid){this.error=s.error;return}this.startUploads(e)},validateFiles(e){let s=this.uploadedFiles.length+e.length;if(this.config.maxFiles&&s>this.config.maxFiles)return{valid:!1,error:`Maximum ${this.config.maxFiles} files allowed. You have ${this.uploadedFiles.length} files and are trying to add ${e.length} more.`};for(let t of e){if(this.config.maxSize&&t.size>this.parseSize(this.config.maxSize))return{valid:!1,error:`File "${t.name}" (${this.formatFileSize(t.size)}) exceeds maximum size of ${this.config.maxSize}`};if(this.config.minSize&&t.size<this.parseSize(this.config.minSize))return{valid:!1,error:`File "${t.name}" (${this.formatFileSize(t.size)}) is smaller than minimum size of ${this.config.minSize}`};if(this.config.acceptedFileTypes.length>0&&!this.config.acceptedFileTypes.some(i=>i.includes("/")?i.endsWith("/*")?t.type.startsWith(i.slice(0,-1)):t.type===i:t.name.toLowerCase().endsWith(i.toLowerCase())))return{valid:!1,error:`File "${t.name}" is not an accepted file type. Accepted types: ${this.config.acceptedFileTypes.join(", ")}`}}return{valid:!0}},async startUploads(e){this.uploading=!0;let s=e.map(i=>({id:this.generateFileKey(),file:i,name:i.name,size:i.size,type:i.type,progress:0,status:"pending",speed:null,uploadedBytes:0,chunks:[],uploadedChunks:0,totalChunks:this.config.isChunked?Math.ceil(i.size/this.config.chunkSize):1,startTime:null,lastProgressTime:null}));this.uploadingFiles=[...this.uploadingFiles,...s];let t=new Array(this.config.maxParallelUploads).fill(null),l=s.map(async i=>{await this.waitForSlot(t,i.id);try{await this.uploadFile(i);let a=this.uploadingFiles.findIndex(o=>o.id===i.id);a!==-1&&(this.uploadingFiles[a].status="completed",this.uploadingFiles[a].progress=100,this.uploadedFiles.push({key:i.id,name:i.name,size:i.size,type:i.type,url:this.uploadingFiles[a].url}))}catch(a){if(a.name!=="AbortError"){let o=this.uploadingFiles.findIndex(r=>r.id===i.id);o!==-1&&(this.uploadingFiles[o].status="error",this.uploadingFiles[o].error=a.message),console.error("Upload error:",a)}}finally{let a=t.findIndex(o=>o===i.id);a!==-1&&(t[a]=null)}});await Promise.allSettled(l),this.uploadingFiles=this.uploadingFiles.filter(i=>i.status!=="completed"),this.uploading=this.uploadingFiles.some(i=>i.status==="uploading"||i.status==="pending"),this.updateLivewireState()},async waitForSlot(e,s){return new Promise(t=>{let l=()=>{let i=e.findIndex(a=>a===null);i!==-1?(e[i]=s,t()):setTimeout(l,100)};l()})},async uploadFile(e){let s=this.uploadingFiles.findIndex(t=>t.id===e.id);s!==-1&&(this.uploadingFiles[s].status="uploading",this.uploadingFiles[s].startTime=Date.now(),this.uploadingFiles[s].lastProgressTime=this.uploadingFiles[s].startTime),this.config.isChunked&&e.file.size>this.config.chunkSize?await this.uploadFileInChunks(e):await this.uploadFileDirectly(e)},async uploadFileInChunks(e){let s=e.file,t=Math.ceil(s.size/this.config.chunkSize);e.totalChunks=t,e.chunks=new Array(t).fill(!1);for(let l=0;l<t;l++){if(this.abortControllers.has(e.id))throw new Error("Upload cancelled");let i=l*this.config.chunkSize,a=Math.min(i+this.config.chunkSize,s.size),o=s.slice(i,a);await this.uploadChunk(e,o,l,t);let r=this.uploadingFiles.findIndex(d=>d.id===e.id);r!==-1&&(this.uploadingFiles[r].chunks[l]=!0,this.uploadingFiles[r].uploadedChunks=this.uploadingFiles[r].chunks.filter(Boolean).length,this.uploadingFiles[r].uploadedBytes=this.uploadingFiles[r].uploadedChunks*this.config.chunkSize,this.uploadingFiles[r].progress=Math.round(this.uploadingFiles[r].uploadedChunks/t*100),this.updateSpeed(this.uploadingFiles[r]))}},async uploadFileDirectly(e){let s=new FormData;s.append("file",e.file),s.append("fileKey",e.id),s.append("name",e.file.name);let t=new AbortController;this.abortControllers.set(e.id,t);try{let l=await fetch(this.config.chunkUploadUrl,{method:"POST",body:s,signal:t.signal,headers:{"X-CSRF-TOKEN":this.getCsrfToken()}});if(!l.ok)throw new Error(`HTTP ${l.status}: ${l.statusText}`);let i=await l.json();if(!i.success)throw new Error(i.message||"Upload failed");let a=this.uploadingFiles.findIndex(o=>o.id===e.id);a!==-1&&(this.uploadingFiles[a].url=i.url,this.uploadingFiles[a].progress=100,this.uploadingFiles[a].uploadedBytes=e.file.size,this.updateSpeed(this.uploadingFiles[a]))}finally{this.abortControllers.delete(e.id)}},async uploadChunk(e,s,t,l){let i=new FormData;i.append("file",s),i.append("fileKey",e.id),i.append("chunk",t),i.append("chunks",l),i.append("name",e.file.name);let a=new AbortController;this.abortControllers.set(`${e.id}_${t}`,a);try{let o=await fetch(this.config.chunkUploadUrl,{method:"POST",body:i,signal:a.signal,headers:{"X-CSRF-TOKEN":this.getCsrfToken()}});if(!o.ok)throw new Error(`HTTP ${o.status}: ${o.statusText}`);let r=await o.json();if(!r.success)throw new Error(r.message||"Upload failed");r.completed&&(e.url=r.url)}finally{this.abortControllers.delete(`${e.id}_${t}`)}},updateSpeed(e){let s=Date.now(),t=s-e.lastProgressTime,l=(s-e.startTime)/1e3;if(t>=500&&l>0){let i=e.uploadedBytes/l;e.speed=this.formatFileSize(i),e.lastProgressTime=s}else l>0&&!e.speed&&(e.speed="calculating...")},async cancelUpload(e){Array.from(this.abortControllers.entries()).filter(([t])=>t.startsWith(e)).map(([,t])=>t).forEach(t=>{try{t.abort()}catch(l){console.debug("Controller abort error (expected):",l)}});try{await fetch(this.config.chunkCancelUrl,{method:"POST",headers:{"Content-Type":"application/json","X-CSRF-TOKEN":this.getCsrfToken()},body:JSON.stringify({fileKey:e})})}catch(t){console.error("Error cancelling upload:",t)}this.uploadingFiles=this.uploadingFiles.filter(t=>t.id!==e),this.uploading=this.uploadingFiles.some(t=>t.status==="uploading"||t.status==="pending")},async cancelAllUploads(){let e=this.uploadingFiles.filter(i=>i.status==="uploading"||i.status==="pending").length;if(e===0||!confirm(`Are you sure you want to cancel all ${e} upload${e>1?"s":""}?`))return;this.abortControllers.forEach(i=>{try{i.abort()}catch(a){console.debug("Controller abort error (expected):",a)}}),this.abortControllers.clear();let l=this.uploadingFiles.filter(i=>i.status==="uploading"||i.status==="pending").map(async i=>{try{await fetch(this.config.chunkCancelUrl,{method:"POST",headers:{"Content-Type":"application/json","X-CSRF-TOKEN":this.getCsrfToken()},body:JSON.stringify({fileKey:i.id})})}catch(a){console.error("Error cancelling upload:",a)}});await Promise.allSettled(l),this.uploadingFiles=this.uploadingFiles.filter(i=>i.status!=="uploading"&&i.status!=="pending"),this.uploading=!1},async retryUpload(e){let s=this.uploadingFiles.findIndex(l=>l.id===e);if(s===-1)return;let t=this.uploadingFiles[s];if(t.status==="error"){this.uploadingFiles[s].status="pending",this.uploadingFiles[s].progress=0,this.uploadingFiles[s].error=null,this.uploadingFiles[s].uploadedBytes=0,this.uploadingFiles[s].uploadedChunks=0,this.uploadingFiles[s].chunks=[],this.uploadingFiles[s].speed=null,this.uploading=!0;try{await this.uploadFile(t);let l=this.uploadingFiles.findIndex(i=>i.id===e);l!==-1&&(this.uploadingFiles[l].status="completed",this.uploadingFiles[l].progress=100,this.uploadedFiles.push({key:t.id,name:t.name,size:t.size,type:t.type,url:this.uploadingFiles[l].url}))}catch(l){if(l.name!=="AbortError"){let i=this.uploadingFiles.findIndex(a=>a.id===e);i!==-1&&(this.uploadingFiles[i].status="error",this.uploadingFiles[i].error=l.message)}}this.uploading=this.uploadingFiles.some(l=>l.status==="uploading"||l.status==="pending")}},async removeFile(e){let s=this.uploadedFiles.find(l=>l.key===e);if(!(!s||!confirm(`Are you sure you want to delete "${s.name}"?`)))try{let l=s.url||"";if(l.includes("/storage/")){let o=l.indexOf("/storage/");l=l.substring(o+9)}let i=await fetch(this.config.chunkDeleteUrl,{method:"DELETE",headers:{"Content-Type":"application/json","X-CSRF-TOKEN":this.getCsrfToken()},body:JSON.stringify({fileKey:e,path:l})});if(!i.ok){let o=await i.text();throw new Error(`HTTP ${i.status}: ${i.statusText} - ${o}`)}let a=await i.json();if(!a.success)throw new Error(a.message||"Failed to delete file");this.uploadedFiles=this.uploadedFiles.filter(o=>o.key!==e),this.updateLivewireState()}catch(l){console.error("Error deleting file:",l),this.error=`Failed to delete file: ${l.message}`,setTimeout(()=>{this.error=null},5e3)}},updateLivewireState(){this.updatingState=!0;let e=this.uploadedFiles.map(s=>s.url&&s.url.includes("/storage/")?s.url.replace("/storage/","").split("/").pop():s.name);this.state=e,setTimeout(()=>{this.updatingState=!1},100)},cleanup(){try{this.cancelAllUploads()}catch(e){console.debug("Cleanup error (expected during page unload):",e)}},generateFileKey(){return Date.now().toString(36)+Math.random().toString(36).substring(2)},formatFileSize(e){if(e===0)return"0 Bytes";let s=1024,t=["Bytes","KB","MB","GB","TB"],l=Math.floor(Math.log(e)/Math.log(s));return parseFloat((e/Math.pow(s,l)).toFixed(2))+" "+t[l]},parseSize(e){let s={B:1,BYTES:1,KB:1024,MB:1048576,GB:1073741824,TB:1099511627776},t=e.match(/^(\d+(?:\.\d+)?)\s*(\w+)$/i);if(t){let l=parseFloat(t[1]),i=t[2].toUpperCase();return l*(s[i]||1)}return parseInt(e)||0},getCsrfToken(){return document.querySelector('meta[name="csrf-token"]')?.getAttribute("content")||""},buildFileUrl(e){let s=this.config.storage;return s.disk==="public"?`/storage/${s.finalDir}/${e}`:`/storage/${s.finalDir}/${e}`}}}export{u as default};
